<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../liquid.js/liquid-import.html">


<script>
  (function () {
    var templateCache = {};

    Polymer({

      is: 'at-core-view',
      _scopeCssViaAttr: true,
      properties: {
        model: {
          value: null,
          notify: true
        }
      },

      observers: [
        'modelChanged(model.*)'
      ],

      templateCache: {},

      created: function () {
        this.templateCache = templateCache;
      },

      ready: function () {

      },

      render: function () {
        try {

          var tmpl = this._getCompiledTemplate();
          if (!tmpl) return;

          tmpl.assigns = {};  // initialize template data, this should probably happen in liquid.js .render() in the future
          var html = tmpl.render(this.model);

          var parent = Polymer.dom(this).getOwnerRoot().host;

          this.root.innerHTML = html;

          // -- parse appened code for list of on-* event bindings --
          var list = [];
          Polymer.Annotations._parseNodeAnnotations(this.root, list);

          // strange it seems to be required to manually trigger the upgrade?, probably because innerHTML was assigned directly
          if (window.CustomElements && CustomElements.upgradeSubtree) {
            CustomElements.upgradeSubtree(this.root);
          }

          // transform ShadyDom styles of innerHTML
          if (!Polymer.Settings.useShadow) Polymer.StyleTransformer.dom(this.root, parent.is, true);


          // -- create listeners on parent node for on-* events
          list.forEach(function (a) {
            if (a.events && a.events.length) {
              var node = this._findAnnotatedNode(this.root, a);
              a.events.forEach(function (e) {
                parent.listen(node, e.name, e.value);
              }, this);
            }
          }, this);

        } catch (ex) {
          var em = 'Exception caught at-core-view.render: ' + (ex.stack || ex);
          console.log(em);
          var emdiv = document.createElement('div');
          emdiv.innerHTML = em;
          Polymer.dom(this.root).appendChild(emdiv);
        }
      },

      _findAnnotatedNode: function (root, annote) {
 
		  // recursively ascend tree until we hit root
		  var parent = annote.parent &&
			Polymer.Annotations.findAnnotatedNode(root, annote.parent);
		  // unwind the stack, returning the indexed node at each level
		  if (parent) {
			// note: marginally faster than indexing via childNodes 
			// (http://jsperf.com/childnodes-lookup)
			for (var n=parent.firstChild, i=0; n; n=n.nextSibling) {
			  if (annote.index === i++) {
				return n;
			  }
			}
		  } else {
			return root;
		  }
      },

      _getNodesInnerHTML: function (nodes) {
        // generates combined innerHTML of an array of nodes
        var html = "";
        for (var i = 0, ii = nodes.length; i < ii; i++) {
          var node = nodes[i];

          // text node
          if (node.nodeType == 3) html += node.textContent;

          // html node
          if (node.nodeType == 1) html += node.outerHTML;

        }

        return html;
      },
      created: function () {

      },
      _getCompiledTemplate: function () {

        if (this.model == null) return; // model not yet initialized

        // if cached - return compiled template for this node
        if (!!this._liquidTemplate) return this._liquidTemplate;

        var cacheKey = "", cacheEntry;
        var tmpl = null;

        if (this.parentNode) {
          if (this.parentNode.id) cacheKey = this.parentNode.id;          
          if (!cacheKey && (this.parentNode.nodeName && this.parentNode.nodeName != "#document-fragment")) cacheKey = this.parentNode.nodeName;
          if (!cacheKey && (this.parentNode.domHost)) cacheKey = this.parentNode.domHost.nodeName;
        }

        // use compiled template if already cached
        if (cacheKey) {
          cacheEntry = this.templateCache[cacheKey];
        }

        if (cacheEntry && cacheKey) {

          tmpl = cacheEntry.compiledTemplate;

        } else {

            // get template source
            var srctmpl = Polymer.dom(this).querySelector('template');
            var src = this._getNodesInnerHTML(srctmpl._content.childNodes);
            //src = srctmpl.innerHTML; // requires template to be wrapped into <template preserve-content> !

            if (!src) return null;

          tmpl = Liquid.parse(src);

          // store compiled template for parent element in cache
          if (cacheKey) {
            this.templateCache[cacheKey] = {
              template: src,
              compiledTemplate: tmpl
            }
          }

          if (!!this._liquidTemplate && JSON.stringify(this._liquidTemplate) != JSON.stringify(tmpl)) debugger;

          // store compiled template also per node
          this._liquidTemplate = tmpl;

        }

        return tmpl;
      },


      modelChanged: function () {
        this.render();
      }

    });

  })();
</script>

