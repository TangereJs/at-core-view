<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../liquid.js/liquid-import.html">
<link rel="import" href="../at-theme/at-theme.html">

<script>
  (function () {
    var templateCache = {};

    Polymer({
      is: 'at-core-view',
      properties: {
        model: {
          type: Object,
          value: null
        },
        value: {
          type: Object,
          value: null,
          //value: function () {
          //  return {
          //    items: [
          //      {
          //        name: 'C-3PO'
          //      },
          //      {
          //        name: 'R2D2'
          //      }
          //  ]
          //  };
          //},
          xtype: 'json'
        },
        view: {
          type: String,
          value: null, // "{% for item in items %}\n{{ item.name }}\n{% endfor %}",
          xtype: 'code',
          mode: "liquid"
        },
        modelRoot: {
          type: String,
          value: ""
        }
      },

      observers: [
        'render(model.*,value.*,view)'
      ],

      $meta: [{
        title: "Liquid View",
        type: "element",
        xtype: "at-core-view"
      }],


      templateCache: {},

      created: function () {
        this.templateCache = templateCache;
      },

      ready: function () {

      },

      _getObjPath: function (obj, path) {

        if (!path) return obj;
        var paths = path.split('.'),
          current = obj;

        for (var i = 0; i < paths.length; ++i) {
          if (current[paths[i]] == undefined) {
            return undefined;
          } else {
            current = current[paths[i]];
          }
        }
        return current;
      },

      actionListener: function (event) {

        this.value = this.modelRoot ? event.detail.model : event.detail.model.state;

      },

      render: function () {

        var tmpl = this._getCompiledTemplate();
        if (!tmpl) return;

        // render immediately if all custom elements are already loaded
        if (tmpl.loaded) {
          this._render(tmpl.compiledTemplate);
          return;
        }

        // import all referenced custom elements, render template when imports are finished
        this._pendingImports = tmpl.customElements.length;
        this._tmpl = tmpl;

        for (var i = 0; i < tmpl.customElements.length; i++) {

          var el = tmpl.customElements[i];

          el = "../" + el + "/" + el + ".html";

          this.importHref(el, function (e) {
            this._pendingImports--;

            if (this._pendingImports < 1) {
              this._tmpl.loaded = true;              
              this._render(this._tmpl.compiledTemplate);
            }
          }, function (e) {
            // loading error
            console.log("import failed: " + e.target.href);
          });
        }
      },

      _render: function (tmpl) {

        try {

          var parent = Polymer.dom(this).getOwnerRoot().host;
          this._parent = parent;

          tmpl.assigns = {}; // initialize template data, this should probably happen in liquid.js .render() in the future

          // callback to localize
          tmpl.i18nCallback = function () {
            var r = this._parent.T.apply(this._parent, arguments);
            return r;
          }.bind(this);

          var root = this.value || this.model;
          if (this.modelRoot) root = this._getObjPath(root, this.modelRoot);

          var html = tmpl.render(root);

          Polymer.dom(this.root).innerHTML = html;


          // -- parse appened code for list of on-* event bindings --
          var list = [];
          Polymer.Annotations._parseNodeAnnotations(this.root, list);

          // -- create listeners on parent node for on-* events
          list.forEach(function (a) {
            if (a.events && a.events.length) {
              var node = this._findAnnotatedNode(this.root, a);
              a.events.forEach(function (e) {
                parent.listen(node, e.name, e.value);
              }, this);
            }
          }, this);

        } catch (ex) {
          var em = 'Exception caught at-core-view.render: ' + (ex.stack || ex);
          console.log(em);
          var emdiv = document.createElement('div');
          emdiv.innerHTML = em;
          Polymer.dom(this.root).appendChild(emdiv);
        }
      },

      _findAnnotatedNode: function (root, annote) {

        // recursively ascend tree until we hit root
        var parent = annote.parent &&
          Polymer.Annotations.findAnnotatedNode(root, annote.parent);
        // unwind the stack, returning the indexed node at each level
        if (parent) {
          // note: marginally faster than indexing via childNodes 
          // (http://jsperf.com/childnodes-lookup)
          for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
            if (annote.index === i++) {
              return n;
            }
          }
        } else {
          return root;
        }
      },

      _getNodesInnerHTML: function (nodes) {
        // generates combined innerHTML of an array of nodes
        var html = "";
        for (var i = 0, ii = nodes.length; i < ii; i++) {
          var node = nodes[i];

          // text node
          if (node.nodeType == 3) html += node.textContent;

          // html node
          if (node.nodeType == 1) html += node.outerHTML;

        }

        return html;
      },
      created: function () {

      },
      _getCompiledTemplate: function () {

        if (!this.model && !this.value) return; // model not yet initialized

        // if cached & static view - return compiled template for this node
        if (!!this._liquidTemplate && !this.view) return this._liquidTemplate;

        var cacheKey = "",
          cacheEntry;
        var tmpl = null;
        
        // if we is property use view itself as cachekey
        if (this.view) cacheKey = this.view;

        // use compiled template if already cached
        if (cacheKey) {
          cacheEntry = this.templateCache[cacheKey];
          if (cacheEntry) {
            return cacheEntry;
          }
        }

        // get template source
        var src = this.view; // start with view property

        // use inner template when provided 
        if(!src) {
        var srctmpl = Polymer.dom(this).querySelector('template');
        if (!srctmpl && !src) return null;

        if (srctmpl) {
          src = this._getNodesInnerHTML(srctmpl._content.childNodes);
          //src = srctmpl.innerHTML; // requires template to be wrapped into <template preserve-content> !
          this.view = src; // save initial static template, triggers observer
          return null;
        }}

        if (!src) return null;

        // use template as cacheKey if we don't have a key yet
        if (!cacheKey) {
          cacheKey = src;
          cacheEntry = this.templateCache[cacheKey];
          if (cacheEntry) {
            return cacheEntry;
          }
        }

        
        tmpl = Liquid.parse(src);

        var elPattern = /<\w+-\w+((\s+\w+(\s*=\s*(?:"(.|\n)*?"|'(.|\n)*?'|[^'">\s]+))?)+\s*|\s*)>/gi;
        var ctags = src.match(elPattern);
        var ces = {},
          p0 = 0,
          p1 = 0;

        // convert <a-b> <a-b checked> to distinct list of custom elment names
        for (var i = 0; i < ctags.length; i++) {
          var tag = ctags[i];
          p0 = tag.indexOf(">");
          p1 = tag.indexOf(" ");

          if (p1 >= 0) p0 = p1;

          tag = tag.substr(1, p0 - 1);

          ces[tag] = true;
        }

        ces = Object.getOwnPropertyNames(ces);

        tmpl = {
          template: src,
          compiledTemplate: tmpl,
          customElements: ces,
          loaded: ces.length == 0
        };

        // store compiled template for parent element in cache
        if (cacheKey) {
          this.templateCache[cacheKey] = tmpl;
        }

        if (!!this._liquidTemplate && JSON.stringify(this._liquidTemplate) != JSON.stringify(tmpl)) debugger;

        // store compiled template also per node
        this._liquidTemplate = tmpl;



        return tmpl;
      }


    });

  })();
</script>