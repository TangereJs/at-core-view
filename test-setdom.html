<link rel="import" href="../tangere/tangere.html" />
<link rel="import" href="../at-theme/at-theme.html" />
<link rel="import" href="../at-core-style-classes/at-core-style-classes.html" />

<script src="lib/set-dom.js"></script>

<dom-module id="test-setdom">
  <template>
    <style include="at-core-style-classes">
      :host {
        display: block;
        box-sizing: border-box;

        margin: 4px;
        padding: 4px;
        border: 1px solid purple;
      }

      .sd-column {
        margin: 4px;
        padding: 4px;
        border: 1px solid purple;
      }
    </style>
      
    <div class="layout-horizontal">
      <div id="innerHtmlContainer" class="sd-column flex"></div>
      <div id="setdomContainer" class="sd-column flex"><div></div></div>
    </div>

  </template>
</dom-module>
<script>
  Polymer({
    is: "test-setdom",
    properties: {
      html: {
        type: String,
        value: '',
        observer: '_htmlChanged'
      }
    },

    ready: function () {

    },

    _htmlChanged: function(newValue, oldValue) {
      if (!newValue) return;

      // set the innerHTML to be used as the expected values
      Polymer.dom(this.$.innerHtmlContainer).innerHTML = newValue;

      // use the setDom to set the html to be used as actual values
      var stPlaceholder = Polymer.dom(this.$.setdomContainer).firstChild;
      // we need placeholder because setDOM replaces it with newValue

      var div = document.createElement('div');
      Polymer.dom(div).innerHTML = newValue;

      setDOM(stPlaceholder, div.firstChild);
      // setDom doesn't operate on the localDOM
      var unscopedElements = Polymer.dom(this.$.setdomContainer).childNodes;
      unscopedElements.forEach(function(node) { 
        this.scopeSubtree(node);
      }, this);

      // scopeSubtree adds style-scope without a check if it already exists
      // we walk unscopedElements and remove style-scope if it exists more than once
      // There is a bug in scopeSubtree function where it will walk an elements shadyRoot and apply style-scope if parent element, which is a bug
      // we want to remove style-scoping only from polymerjs elements shadyDOM only. We can identify such element by having a shadyDom property
      // var thisEltName = this.is;
      // unscopedElements.forEach(function(node) { 
      //   this._removeDuplicateStyleScoping(node, thisEltName);
      // }, this);
    },

    // _removeDuplicateStyleScoping: function(element, styleScopeClass) {
    //   // if element doesn't have classList property return
    //   if (!element.classList) return;

    //   var count = this._computeClassNameCount(element.classList, 'style-scope');
    //   if (count > 1) {
    //     // TODO(ij): Not enough, remove will remove first occurence not last. I need last removed
    //     element.classList.remove('style-scope');
    //     // removing prent element's name is not an issue since it will be last anyway
    //     element.classList.remove(styleScopeClass);
    //   }

    //   var childNodes = [];
    //   if (element.root) {
    //     childNodes = Polymer.dom(element.root).childNodes;
      
    //   } else {
    //     childNodes = element.childNodes;
    //   }

    //   if (!childNodes.length) return;

    //   childNodes.forEach(function(node){ 
    //     this._removeDuplicateStyleScoping(node, styleScopeClass);
    //   }, this);

    //   // if shadowDOM is used we do not have this issue
    // },

    // _computeClassNameCount: function(classList, className) {
    //   var count = 0;
    //   for (var i=0; i<classList.length; i++) {
    //     var currName = classList[i];
    //     if (currName === className) count++;
    //   }
    //   return count;
    // },

    get innerHtmlChildNodes() {
      return Polymer.dom(this.$.innerHtmlContainer).childNodes;
    },

    get setdomChildNodes() {
      return Polymer.dom(this.$.setdomContainer).childNodes;
    }
  });
</script>
